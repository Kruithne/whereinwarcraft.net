const documentReady = () => new Promise(t => {
	"loading" !== document.readyState ? t() : document.addEventListener("DOMContentLoaded", t, {
		once: !0
	})
}),
preloadImage = t => new Promise(e => {
	const s = document.createElement("img");
	s.setAttribute("src", t), s.complete ? e() : s.addEventListener("load", e, {
		once: !0
	})
}),
loadBackgroundSmooth = async (t, e) => {
	e = e || t.getAttribute("data-bg"), await preloadImage(e), t.style.display = "block", t.style.backgroundImage = "url(" + e + ")", t.style.opacity = 1
}, delay = t => new Promise(e => {
	setTimeout(e, t)
}), pointDistance = (t, e, s, i) => {
	let a = t - s,
		o = e - i;
	return Math.sqrt(a * a + o * o)
}, onButtonClick = (t, e, s = !0) => {
	const i = i => (t.classList.contains("disabled") || (s && t.classList.add("disabled"), e()), i.preventDefault(), i.stopPropagation(), !1);
	t.addEventListener("mousedown", i), t.addEventListener("touchstart", i)
}, $ = (t, e = !1) => e ? document.querySelectorAll(t) : document.querySelector(t), sendRequest = async t => {
	const e = await fetch("endpoint.php", {
			method: "POST",
			headers: {
				Accept: "application/json",
				"Content-Type": "application/json"
			},
			body: JSON.stringify(t)
		}),
		s = await e.json();
	return s.error && console.error(s.error), s
}, MAPS = {
	cata: {
		dir: "tiles",
		maxZoom: 7,
		background: "rgb(0, 29, 40)",
		mapID: 0
	},
	classic: {
		dir: "tiles_classic",
		maxZoom: 6,
		background: "rgb(0, 29, 40)"
	},
	tbc: {
		dir: "tiles_tbc",
		maxZoom: 6,
		background: "rgb(0, 0, 0)",
		mapID: 1
	},
	wod: {
		dir: "tiles_wod",
		maxZoom: 7,
		background: "rgb(8, 27, 63)",
		mapID: 2
	},
	bfa: {
		dir: "tiles_bfa",
		maxZoom: 7,
		background: "rgb(0, 29, 40)",
		mapID: 3
	}
}, MAP_INDEX = new Map;
for (const t in MAPS) {
const e = MAPS[t];
void 0 !== e.mapID && MAP_INDEX.set(e.mapID, t)
}
const MAX_LIVES = 3,
GUESS_THRESHOLD = 2.4,
BOD_RADIUS = .8;
class GameState {
constructor(t, e) {
	this.ui = t, this.panorama = e, this.token = null, this.isClassic = !1, this.gameStarted = !1
}
get isAlive() {
	return this.playerLives > 0
}
get playerAccuracy() {
	if (0 === this.playerGuesses.length) return 0;
	let t = 0;
	for (let e of this.playerGuesses) t += e;
	return Math.ceil(t / this.playerGuesses.length)
}
async startGame(t, e = null, s = !1) {
	this.isClassic = t, this.reset();
	const i = {
		action: "init",
		mode: t ? 2 : 1
	};
	null !== e && (i.resumeToken = e), null !== this.token && (i.clearToken = this.token), s || await this.ui.enterGame(t);
	const a = await sendRequest(i);
	localStorage.setItem("wiw-session", a.token), void 0 !== a.resumeLives && void 0 !== a.resumeScore && (this.playerLives = a.resumeLives, this.playerPoints = a.resumeScore, this.currentRound = this.playerPoints + (MAX_LIVES - this.playerLives), this.playerGuesses = JSON.parse(localStorage.getItem("wiw-local-guesses")), Array.isArray(this.playerGuesses) || (this.playerGuesses = []), this.updateDisplay()), this.token = a.token, this.currentLocation = a.location, this.nextRound(), this.gameStarted = !0
}
updateDisplay() {
	this.ui.$scoreLives.textContent = this.playerLives, this.ui.$scoreRounds.textContent = this.currentRound, this.ui.$scoreAccuracy.textContent = this.playerAccuracy
}
reset() {
	this.currentRound = 0, this.playerPoints = 0, this.currentLocation = null, this.playerLives = MAX_LIVES, this.playerGuesses = [], this.updateDisplay()
}
async restartGame() {
	this.ui.setGameGlowBorder("transparent"), this.ui.$gameOverSpirit.style.opacity = 0, this.ui.$gameOver.style.opacity = 0, await delay(430), this.ui.$gameOver.style.display = "none", this.startGame(this.isClassic, null, !0)
}
async nextRound() {
	null !== this.currentLocation ? (this.currentRound++, this.ui.$scoreRounds.textContent = this.currentRound, await this.panorama.setLocation(this.currentLocation), this.ui.setGameGlowBorder("transparent"), this.ui.hideMap(), this.ui.clearMap(), this.ui.resetMapZoom(), this.ui.enableMap(), this.ui.$buttonNextRound.style.display = "none", this.ui.$buttonViewLocation.style.display = "block", this.ui.$buttonSubmitGuess.style.display = "block", this.ui.$buttonSubmitGuess.classList.add("disabled")) : (localStorage.removeItem("wiw-session"), this.ui.showGameOver(this.isAlive, this.playerPoints))
}
async processGuess() {
	this.ui.disableMap();
	const t = this.ui.mapMarker.getLatLng(),
		e = this.ui.selectedMap;
	let s = "blue",
		i = GUESS_THRESHOLD;
	const a = {
		action: "guess",
		token: this.token,
		lat: t.lat,
		lng: t.lng
	};
	"classic" !== e && (a.mapID = MAPS[e].mapID);
	const o = await sendRequest(a),
		n = {
			lat: o.lat,
			lng: o.lng
		};
	switch (o.result) {
		case 0:
			s = "red", this.ui.showMapPath(n, t, s), this.ui.setGameGlowBorder("red");
			break;
		case 1:
			s = "yellow";
			break;
		case 2:
			s = "green", i = BOD_RADIUS, this.ui.setGameGlowBorder("green")
	}
	o.location ? this.currentLocation = o.location : this.currentLocation = null, this.playerPoints = o.score, this.playerLives = o.lives, this.ui.$scoreLives.textContent = o.lives, void 0 !== o.mapID && this.ui.setSelectedMap(MAP_INDEX.get(o.mapID)), this.ui.setMapInfo(o.zoneName, o.locName), this.playerGuesses.push(o.distPct), localStorage.setItem("wiw-local-guesses", JSON.stringify(this.playerGuesses)), this.ui.$scoreAccuracy.textContent = this.playerAccuracy, this.ui.showMapCircle(n, s, i), this.ui.panMap(n), this.ui.$buttonSubmitGuess.style.display = "none", this.ui.$buttonViewLocation.style.display = "none", this.ui.$buttonNextRound.classList.remove("disabled"), this.ui.$buttonNextRound.style.display = "block"
}
async sendScore() {
	let t = this.ui.$fieldSendScore.value.trim();
	if (t.length > 0 && null !== this.token && this.playerPoints > 0) {
		t = t.substring(0, 20);
		let e = localStorage.getItem("wiw-score-token");
		null === e && (e = ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, t => (t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16)), localStorage.setItem("wiw-score-token", e)), await sendRequest({
			action: "submit",
			token: this.token,
			name: t,
			uid: e
		}), this.ui.$buttonSubmitScore.textContent = "Score Sent", this.ui.$buttonSubmitScore.classList.add("disabled"), this.ui.hideSendScore()
	} else this.ui.$buttonSendScore.classList.remove("disabled")
}
}
class UI {
constructor() {
	this._isMapEnabled = !1, this._init(), this.throttleLeaderboard = !1, this.isLeaderboardShown = !1, this.selectedMap = null, this.isMapShown = !1
}
_init() {
	this.$gameIntro = $("#intro"), this.$gameBanners = $(".game-banner", !0), this.$gameFrame = $("#game-frame"), this.$gameContent = $("#game-content"), this.$gameImage = $("#game-image"), this.$gameMap = $("#game-map"), this.$gameCanvas = $("#game-drag-inner"), this.$gameOver = $("#game-over"), this.$gameOverSpirit = $("#game-over-spirit"), this.$gameOverTitle = $("#game-over-title"), this.$gameOverRounds = $("#game-over-rounds-value"), this.$gameOverAccuracy = $("#game-over-accuracy-value"), this.$sendScore = $("#send-score"), this.$buttonSendScore = $("#btn-send-score"), this.$fieldSendScore = $("#field-send-score"), this.$buttonCancelScore = $("#btn-cancel-score"), this.$scoreRounds = $("#game-score-round-value"), this.$scoreAccuracy = $("#game-score-accuracy-value"), this.$scoreLives = $("#game-score-lives-value"), this.$infoZone = $("#game-map-info"), this.$mapSelector = $("#map-selector"), this.$mapSelectorButtons = $(".map-selector-icon", !0);
	for (const t in MAPS) {
		const e = $("#map-selector-" + t);
		MAPS[t].$selector = e, null !== e && e.addEventListener("click", e => {
			this.setSelectedMap(t), e.stopPropagation()
		})
	}
	this.$buttonLeaderboard = $("#game-button-leaderboard"), this.$leaderboard = $("#leaderboard"), this.$buttonViewMap = $("#game-button-map"), this.$buttonViewLocation = $("#game-button-location"), this.$buttonSubmitGuess = $("#game-button-confirm"), this.$buttonNextRound = $("#game-button-next"), this.$buttonReplay = $("#game-button-replay"), this.$buttonPlay = $("#btn-play"), this.$buttonPlayClassic = $("#btn-play-classic"), this.$buttonSubmitScore = $("#game-button-submit");
	for (const t of $(".smooth", !0)) loadBackgroundSmooth(t)
}
setSelectedMap(t) {
	if (this.selectedMap === t) return;
	this.selectedMap = t;
	const e = MAPS[t];
	if ("classic" === t) this.$mapSelector.style.display = "none";
	else {
		this.$mapSelector.style.display = "flex";
		for (const t of this.$mapSelectorButtons) t.classList.remove("selected");
		null !== e.$selector && e.$selector.classList.add("selected")
	}
	this.$gameMap.style.background = e.background, this.map && this.map.remove(), this.map = L.map("game-map", {
		attributionControl: !1,
		crs: L.CRS.Simple
	}), this.resetMapZoom(), L.tileLayer("images/" + e.dir + "/{z}/{x}/{y}.png", {
		maxZoom: e.maxZoom
	}).addTo(this.map), this.map.on("click", t => this._onMapClick(t))
}
async toggleLeaderboard() {
	if (this.isLeaderboardShown) this.isLeaderboardShown = !1, this.$leaderboard.style.display = "none";
	else if (this.isLeaderboardShown = !0, this.$leaderboard.style.display = "block", !this.throttleLeaderboard) {
		this.throttleLeaderboard = !0, this.$leaderboard.innerHTML = "<p>Loading...</p>";
		const t = await sendRequest({
			action: "leaderboard",
			mode: this.isClassic ? 2 : 1
		});
		this.$leaderboard.innerHTML = "";
		let e = 1;
		for (const s of t.players) {
			const t = document.createElement("div");
			t.textContent = e++ + ". " + s.name;
			const i = document.createElement("span");
			i.textContent = s.score + " (" + Math.round(s.accuracy) + "%)", t.appendChild(i), this.$leaderboard.appendChild(t)
		}
		setTimeout(() => {
			this.throttleLeaderboard = !1
		}, 6e4)
	}
}
_onMapClick(t) {
	this._isMapEnabled && (this.mapMarker && this.mapMarker.remove(), this.mapMarker = L.marker([t.latlng.lat, t.latlng.lng]).addTo(this.map), this.$buttonSubmitGuess.classList.remove("disabled"))
}
async showSendScore() {
	this.$gameOver.style.opacity = 0, await delay(430), this.$gameOver.style.display = "none", this.$sendScore.style.opacity = 0, this.$sendScore.style.display = "block", this.$sendScore.style.opacity = 1
}
async hideSendScore() {
	this.$sendScore.style.opacity = 0, await delay(430), this.$sendScore.style.display = "none", this.$gameOver.style.opacity = 0, this.$gameOver.style.display = "block", this.$gameOver.style.opacity = 1
}
resetMapZoom() {
	this.map.setView([-120.90349875311426, 124.75], 2)
}
panMap(t) {
	this.map.panTo([t.lat, t.lng], {
		duration: 1,
		easeLinearity: .1
	})
}
showMapPath(t, e, s) {
	this.mapPath && this.mapPath.remove(), this.mapPath = L.polyline([
		[t.lat, t.lng],
		[e.lat, e.lng]
	], {
		color: s || "red"
	}).addTo(this.map)
}
showMapCircle(t, e, s) {
	this.mapCircle && this.mapCircle.remove(), this.mapCircle = L.circle([t.lat, t.lng], {
		color: e,
		fillColor: e,
		fillOpacity: .5,
		radius: s
	}).addTo(this.map)
}
clearMap() {
	this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null), this.mapPath && (this.mapPath.remove(), this.mapPath = null), this.mapCircle && (this.mapCircle.remove(), this.mapCircle = null), this.$infoZone.style.display = "none"
}
enableMap() {
	this._isMapEnabled = !0
}
disableMap() {
	this._isMapEnabled = !1
}
showMap() {
	this.isMapShown = !0, this.$buttonViewLocation.classList.remove("disabled"), this.mapMarker && this.$buttonSubmitGuess.classList.remove("disabled"), this.$gameMap.style.opacity = 1, this.$gameMap.style.zIndex = 4, this.$gameImage.style.opacity = 0
}
hideMap() {
	this.isMapShown = !1, this.$buttonViewMap.classList.remove("disabled"), this.$gameMap.style.opacity = 0, this.$gameMap.style.zIndex = 1, this.$gameImage.style.opacity = 1
}
setMapInfo(t, e) {
	this.$infoZone.textContent = t + " - " + e, this.$infoZone.style.display = "block"
}
async enterGame(t) {
	return new Promise(e => {
		this.$gameIntro.style.opacity = 0, delay(430).then(() => {
			this.$gameIntro.style.display = "none", this.$gameFrame.style.display = "block", this.$gameFrame.style.opacity = 1;
			for (const t of this.$gameBanners) t.classList.add("extended");
			this.$gameContent.style.opacity = 1, this.isClassic = t, this.setSelectedMap(t ? "classic" : "cata"), e()
		})
	})
}
setGameGlowBorder(t) {
	this.$gameContent.style.boxShadow = "insert " + t + " 0 0 80px"
}
showGameOver(t, e) {
	this.setGameGlowBorder("white"), this.$gameMap.style.opacity = 0, this.$gameImage.style.opacity = 0, delay(430).then(() => {
		this.$gameOverTitle.textContent = t ? "You completed every location." : "You ran out of lives.", this.$gameOverRounds.textContent = e, this.$gameOverAccuracy.textContent = this.$scoreAccuracy.textContent, this.$buttonReplay.classList.remove("disabled"), this.$buttonSendScore.classList.remove("disabled"), this.$buttonSubmitScore.textContent = "Submit Score", e > 0 ? this.$buttonSubmitScore.classList.remove("disabled") : this.$buttonSubmitScore.classList.add("disabled"), loadBackgroundSmooth(this.$gameOverSpirit), this.$gameOver.style.display = "flex", this.$gameOver.style.opacity = 1
	})
}
}
class GamepadHandler {
constructor(t, e, s) {
	this.ui = t, this.state = e, this.panorama = s, this.gamepads = new Set, addEventListener("gamepadconnected", t => this.onGamepadConnected(t)), addEventListener("gamepaddisconnected", t => this.onGamepadDisconnected(t)), this.isPolling = !1, this.updateCallback = (t => this.onUpdate(t)), this.lastClickTime = 0, this.isPanning = !1, this.panClientX = 0, this.panClientY = 0, this.crosshairEnabled = !1
}
get hasGamepads() {
	return this.gamepads.size > 0
}
initCrosshair() {
	if (this.crosshairEnabled) return;
	this.crosshairEnabled = !0;
	const t = this.crosshair = document.createElement("div");
	t.setAttribute("id", "game-map-crosshair"), this.ui.map._container.appendChild(t)
}
constructEvent(t) {
	const e = new MouseEvent(t, {
		clientX: this.panClientX,
		clientY: this.panClientY
	});
	return Object.defineProperty(e, "target", {
		value: this.ui.map._container
	}), e
}
onUpdate(t) {
	if (!this.hasGamepads) return void(this.isPolling = !1);
	const e = navigator.getGamepads();
	for (const s of this.gamepads) {
		const i = e[s];
		if (!this.state.gameStarted) continue;
		const a = i.axes[0];
		Math.abs(a) >= .3 && (this.panorama.offset += 12 * -a, this.ui.$gameCanvas.style.backgroundPosition = this.panorama.offset + "px 0");
		const o = i.axes[2],
			n = i.axes[3];
		if (this.ui.isMapShown && (Math.abs(o) >= .15 || Math.abs(n) >= .15) ? this.isPanning ? (this.panClientX += 12 * -o, this.panClientY += 12 * -n, document.dispatchEvent(this.constructEvent("mousemove"))) : (this.panClientX = 0, this.panClientY = 0, this.isPanning = !0, this.initCrosshair(), this.ui.map._container.dispatchEvent(this.constructEvent("mousedown"))) : this.isPanning && (this.isPanning = !1, document.dispatchEvent(this.constructEvent("mouseup"))), t - this.lastClickTime > 300) {
			const e = i.axes[1];
			if (Math.abs(e) >= .3 && (e > 0 ? document.querySelector(".leaflet-control-zoom-out").click() : document.querySelector(".leaflet-control-zoom-in").click(), this.lastClickTime = t), i.buttons[1].pressed && this.ui.isMapShown && !this.isPanning && this.crosshair) {
				const e = this.ui.map._container,
					s = this.crosshair.getBoundingClientRect();
				this.panClientX = s.left + s.width / 2, this.panClientY = s.top + s.height / 2, this.ui.map.dragging._draggable._moved = !1, e.dispatchEvent(this.constructEvent("click")), this.lastClickTime = t
			}
			if (i.buttons[9].pressed && (this.ui.toggleLeaderboard(), this.lastClickTime = t), i.buttons[5].pressed) {
				const e = document.querySelector(".map-selector-icon.selected");
				if (e) {
					const t = e.nextElementSibling;
					t ? t.click() : e.parentNode.firstElementChild.click()
				}
				this.lastClickTime = t
			} else if (i.buttons[4].pressed) {
				const e = document.querySelector(".map-selector-icon.selected");
				if (e) {
					const s = e.previousElementSibling;
					s ? s.click() : e.parentNode.lastElementChild.click(), this.lastClickTime = t
				}
			}
			i.buttons[0].pressed && ("none" !== this.ui.$buttonNextRound.style.display ? (this.state.nextRound(), this.lastClickTime = t) : this.ui.mapMarker && (this.ui.$buttonSubmitGuess.classList.add("disabled"), this.state.processGuess(), this.lastClickTime = t)), i.buttons[2].pressed && (this.ui.isMapShown ? this.ui.hideMap() : this.ui.showMap(), this.lastClickTime = t)
		}
	}
	requestAnimationFrame(this.updateCallback)
}
onGamepadConnected(t) {
	const e = t.gamepad;
	console.log(e), "standard" === e.mapping && (this.gamepads.add(e.index), this.isPolling || requestAnimationFrame(this.updateCallback))
}
onGamepadDisconnected(t) {
	this.gamepads.delete(t.gamepad.index)
}
}
class Panorama {
constructor(t) {
	this.ui = t, this.isClassic = !1, this.offset = 0, this.anchor = 0, this.isDragging = !1, this._init()
}
setMode(t) {
	this.isClassic = t
}
async setLocation(t) {
	const e = this.isClassic ? "locations_classic" : "locations";
	this.ui.$gameCanvas.style.opacity = 0, await delay(430), loadBackgroundSmooth(this.ui.$gameCanvas, "images/" + e + "/" + t + ".jpg")
}
_init() {
	this.ui.$gameImage.addEventListener("mousedown", t => this._onMouseDown(t)), this.ui.$gameImage.addEventListener("touchstart", t => this._onMouseDown(t)), document.addEventListener("mousemove", t => this._onMouseMove(t)), document.addEventListener("touchmove", t => this._onMouseMove(t)), document.addEventListener("mouseup", t => this._onMouseUp(t)), document.addEventListener("touchend", t => this._onMouseUp(t)), document.addEventListener("touchcancel", t => this._onMouseUp(t))
}
_onMouseMove(t) {
	if (this.isDragging) {
		let e = t.clientX || t.touches[0].clientX,
			s = this.offset + (e - this.anchor);
		this.ui.$gameCanvas.style.backgroundPosition = s + "px 0", t.preventDefault()
	}
}
_onMouseDown(t) {
	this.anchor = t.clientX || t.touches[0].clientX, this.isDragging = !0, t.preventDefault()
}
_onMouseUp(t) {
	if (this.isDragging) {
		let e = t.clientX || t.changedTouches[0].clientX;
		this.isDragging = !1, this.offset = this.offset + (e - this.anchor), t.preventDefault()
	}
}
}(async () => {
await documentReady(), delay(5e3).then(() => {
	const t = $("#front-ruffles");
	t.style.display = "block", delay(1).then(() => {
		t.classList.add("arf")
	})
});
const t = (t, e = null) => {
		s.setMode(t), i.startGame(t, e)
	},
	e = new UI,
	s = new Panorama(e),
	i = new GameState(e, s);
new GamepadHandler(e, i, s);
const a = localStorage.getItem("wiw-session");
null !== a && sendRequest({
	action: "resume",
	token: a
}).then(e => {
	if (!0 === e.resume) {
		const s = $("#front-text-continue");
		s.style.display = "block", s.addEventListener("click", () => t(2 === e.mode, a))
	}
}), onButtonClick(e.$buttonViewMap, () => e.showMap()), onButtonClick(e.$buttonPlay, () => t(!1)), onButtonClick(e.$buttonPlayClassic, () => t(!0)), onButtonClick(e.$buttonViewLocation, () => e.hideMap()), onButtonClick(e.$buttonNextRound, () => i.nextRound()), onButtonClick(e.$buttonReplay, () => i.restartGame()), onButtonClick(e.$buttonSubmitGuess, () => i.processGuess()), onButtonClick(e.$buttonSubmitScore, () => e.showSendScore(), !1), onButtonClick(e.$buttonCancelScore, () => e.hideSendScore(), !1), onButtonClick(e.$buttonSendScore, () => i.sendScore()), onButtonClick(e.$buttonLeaderboard, () => e.toggleLeaderboard(), !1), preloadImage("images/zeppy.png")
})();